### Введение
Stack Editor - блочный, современный редактор для работы с статьями и документациями.

Он расширяем и хорошо организован, имеет привлекательный и гибкий дизайн, поддерживает мобильную версию и имеет плагины для более комфортной и профеесиональной работы.

Редактор разрабатывался для удобного написания статей, их поддержка и редактирование.
 
------
### Установка
У плагина есть несколько версий:
editor.ts - ts версия для разработки 
editor.js - js версия для разработки 
editor.min.js - продакшен версия

**Установка через npm:**

```npm install stack-editor``` - Я ЕЩЕ НЕ УСПЕЛ ДОБАВИТЬ

**Инициализация**

```
import StackEditor from "stack-editor"

const editor = new StackEditor("#holder")
// holder - любой селектор

```
Вы можете начать работать с текстом!

Если хотите добавить больше плагинов или настроек, то вам следует прочитать следубщий пункт:

------

### Архитектура 

#### Инициализации редактора

Вместо одного холдера, вы можете передать объект настроек (но с обязательным холдером):

```
const editor = new StackEditor({

       holder: "#holder", // холдер для контейнера (обязателено) или сам контейнер напрямую

       coreTools: {}, // плагины для ядра редактора

       blockTools: {},  // блочные инструменты

       optionTools: [],  // инструмент настроек блока

       inlineTools: [], // инлайн инструменты

       data: {

           time: Date.now(),

           blocks: [{

                tool: 'paragraph',

                data: {

                    text: ""

                },

            }]

        }, // входные данные редактора для отображения

        baseTool: 'paragraph', // блочный инструмент по умолчанию

        autofocus: false, // автофокус к 1 блоку после инициализации плагина

        purify: null, // еали хотите использовать свой санитайзер, то пожалуйста, но у него должен быть такой же функционал. ( об этом дальше)

        optionInfo: null, // функция для добавления информации в конце меню настроек. (например последнее время изменения) возращает html.

        showBtnsOnLeave: false, // если мышь покидает границы контейнера, то появляюися статичные комплненты редактора

        autoInit: true, // false, если вы хотите сами плзже вызвать метод init()

 })
```

#### Передача плагинов

Плагином является класс или функция.

Если помимо класса вы хотите передать еще и настройки для плагина, то передаете объект под ключем "class", и добавляете другие свойства.

```
{
    paragraph: Paragraph | { class: Paragraph }
}
```

**blockTools:**
```
blockTools: {
    paragraph: Paragraph,
    header: Header,
}
```

Еще стоит передавать категорию под ключем category для правильной и красивой сортировке блочных инструментов.

**optionTools:**
```
optionTools: [
    {
        delete: Delete,
    }
]
```

Опции передаются в виде массива объектов, для красивого разделения сепаратором.

**inlineTools:**
Тоже самоем что и в optionTools

**coreTools:**
Тоже самое что и в blockTools

#### Методы редактора

##### **Работа с блоками:**

``` editor.workspace() ``` - создает контейнер для добавления в него блоков. Нужен если внутри вашего редактора нужно организовать еще одно поле для блоков.

``` editor.newBlock(option) ``` - создание нового блока, возращает либо null либо новый блок.

настройки создания:
```
{

       tool: "paragraph" // используйте свой индетивикатор инструмента. по омулчанию он записан в editor.op.baseTool
       

       toFocus: true,  // означает, что новый блок добавится после блока, на котором сейчас находится фокус
       

       autofocus: true, // ищет поле для ввода внутри и фокусируется на нем.
       

       justReturn: false, // если ненужно добавлять блок на страницу, а просто вернуть его
       

       id: generateUUID(), // можно установить свой id блока, иначе это сделает функция.
       

       box: this.blocksBox, // контейнер для блока (тот самый, который создает workspace). По умолчанию он уже есть.

 }
 ```
 
``` editor.deleteBlock(block) ``` - передаете в качестве html элемента блок и функция правильно его удаляет. не стоит самостоятельно это делать, иначе это может сломать какой нибудь механизм.

``` editor.focusBlock(block, option) ``` - если хотите сфокусировать конкретный блок, в будущем возможен выбор фокуса.

Настрйоки фокуса:
```
{
    focusInp: false, // если хотите сфокусироваться на поле ввода внутри.
}
```

``` editor.blockMeta(block, ?callback) ``` - нужен для обработки мета данных блока.
Всегда возращает метаданные блока.

Если у блока нет метаданных - они создаются для этого блока.
Callback нужен для обработки метаданных блока. Тоесть в коллбек передают meta данные (в виде объекта), которые закреплены за блоком. Возращать ничего не нужно.

Если callback не передан, то функция просто вернет данные, без их обработки.

##### **Меню:**

```editor.newBlockMenu(?block)``` - открывает новое меню выбора блока под блоком, который был передан, иначе под блоком, на котором сфокусирован пользователь. 

Если блоком будет парграф с пустым полем ввода, то над этим блоком будет открыто меню. Иначе под блоком будет создан новый пустой параграф, над которым появится меню

```editor.optionMenu()``` - открывает над сфокусированным блоком меню настроек и взаимодействия над блоком.

```editor.inlineMenu()``` - автоматически открывается после выделения текста. 

У этого меню есть еще и другие методы:

    - editor.openInline() - просто создает меню и добавляет его в редактор, возращая это меню. Если меню уже есть в редаткоре, то возращает это меню.
    - editor.closeInline() - ищет меню в редакторе и закрывает его. Лучше использовать именно этот метод для закрытия инлайн меню, так как закрытие этого меню связана с логикой работы редактора.
    - editor.replaceInline(?menu) - выделение может переместиться, поменять свое положение. Этот метод ищет меню внутри редактора (или вы его передаете) и перемещает его в нужное место под выделением.
    - editor.updateInlineContent(menu) - метод нужен для изменения контента меню после изменения выделения.
    - editor.isInline(?inp) - возращает true или false. определяет, разрашает ли поле ввода использовать inlineMenu в нем. Если вы не передадите поле ввода, то функция сама найдет его по выделению.

##### **Данные:**

```editor.sanitize(html, ?config)``` - передаете html и настрйоки для санитайзера. Возращает чистый html.

Настройки для санитайзера:
```
{
  // санитайзер в разработке
}
```

``` editor.save(?box) ``` - вы передаете контйенер блоков и он возращает данные в формате json. По умолчанию используется главный контейнер.

``` editor.initData(data, ?box) ``` - инициализирует данные, которые возращает метод save. по умолчанию контейнер для добавления блоков используется главный контейнер.

##### **Состояне:**

``` editor.emit(eventType, ?eventData) ``` - вызывает событие с выбранным типом, можно передать доп данные которые потом можно получить из event. Метод возращает event объект.

``` editor.on(eventType, callback, ?config) ``` - отслеживает события, которые вызывает метод emit(). Возращает функцию, которая удаляет слушатель.

В callback передают объект event, который имеет метод prevent() (если событие позволяет, останавливает его) и dispatch() (всплытие слушателей останавливается).
У event есть бинарное свойство event.prevented, event.type - это eventType из editor.emit и бинарное свойство event.dispatched.

Настрйоки слушателя:
```
{
    once: false, // если хотите вызывать слушатель один раз и удалить его, то переадйте под ключем true
}
```

``` editor.off(eventType, callback, ?config) ``` - по переданным данным ищет слушатель и удаляет его.

``` editor.post() ``` - меняет состояние редактора в режим просмотра. Редактирование становится недоступным. Зависит от плагинов, если у них нет режима (метода) post, ести он, конечно, нужен, то сделать блок не редактируеммым у редактора не получится.

``` editor.applyChange() ``` - исскуственно вызывает изменения в редакторе. В будущем будет доступно тип изменения. Для отслеживания изменений, редактор использует MutationObserver.

``` editor.destroy() ``` - уничтожает редактор и он перестает быть доступным вообще, удаляет все слушатели и тп. включая контейнер редактора.


##### **Инструменты:**

``` editor.focus(inp) ``` - передайте поле ввода для установки курсора в конец текста внутри поля ввода.

``` editor.getPosition(el, ?cont) ``` - информация о элементе относительно переданного контейнера, по умолчанию контейнером является главнй контейнер редактора, которые вы передали в холдере.

Возращает объект:

```
 {

       top,

       left,

       bottom,

       right, // -- позиции элемента относительно контейнера 

       height, // -- высота элемента

       width, // -- ширина элемента

 }
```

``` editor.create(compName, ?config) ``` -  создает и возращает клмпонент. Вы можете передать объект настроек. возращает null если комплнента не существует.

``` editor.CET(block, ?isNodeList) ``` - ищет в выбранном блоке ( или лбом другом элементе) редактируемые поле и возрашет его. Если передать в качестве второго аргумента true, то метод вернет все редактируемые поля, которые найдет в виде nodeList. 

##### **Свойства класса редактора:**

``` editor.op ``` - настройки редактора
 
``` editor.cont ``` - основной контейнер редактора.
    content!: HTMLElement 
``` editor.blocksBox ``` - основой контейнер для блоков.
``` editor.btnsBox ``` - контейнер для кнопок навигации
 
``` editor.ui ``` - инструмент для добавления стилей из js. О нем дальше.
``` editor.inline ``` - инструмент для работы с inline.
 
``` editor.comps ``` - тут хранятся коллбеки, которые создают компоненты. ключи - имя компонента
 
```
    // состояние редактора.
    state = { 
        isFakeRange: false, // есть ли сейчас в редакторе фейковое выделение
        focusedBlock: null,  // сфокусированный обьект блока
    } 

// сфокусироованный блок
{
    block, // сам html элемент
    event, // событие по которому был сфокусирован блок, клик или курсор мыши навели
    type, // тип фокуса.
}
```

Тмпы фокусов:
    - mousemove - наведение мыши



``` editor.blocksMeta ``` - WeakMap, там хранятся мета данные блоков.
``` editor.observer ``` - MutationObserver, в начале может быть равным null пока не прошла иницализация.
 
```
// экземпляры классов инструментов
editor.tools:  { 
   core, // инструменты для ядра
   block, // блочные инструменты
   blockOption, // инструменты настроек конкретного блока
   option, // инструменты настрооек блоков
   inline, // инлайн инструменты
}
```

```
// кнопки редактора
editor.btns = { 
    block,
    option,
    blockOption,
    inline,
}
// под индетификаторами блоков закреплена кнопка инструмента
```

```
// разрешения редактора
editor.allowed = { 
        tags, // разрешенные теги, нужны для санитайзера
        attrs, // разрешенные атрибуты, тоже для санитайзера
        inline, // блочные инструменты, которые разрешают использование inline меню внутри своих блоков
}
```

##### **Встроенные плагины:**

###### **UIManager:**

``` editor.ui ``` - экзепляр класса UIManager.

Создает в head тег style под аттрибутом: data-elib-uitheme

**Он имеет следующие мтоды и свойства:**

``` const ui = editor.ui ```

Свойства:

``` ui.config ``` - настройки менеджера стилей.

``` ui._envSelector ``` - тут хранится строка - селектор по умолчанию.

``` ui.envSelector ``` - при установке селкктора - складывает предыдущее значение и новое.

``` ui.style ``` - html элемент style.

``` ui.sheet ``` - таблица стилей элемента style.

``` ui.mixins ``` -  готовые стили. под ключами - названиями миксинов.

``` ui.setRulesLater ``` - если style еще нет в документе, то добавляет запрос на добавление стиля здесь и после инициализации добавляет стили из этого массива.

Методы:

``` ui.env(selector) ``` - меняет базовый селектор на переданный полностью. Возращает функцию для возращения предыдущего селкктора.

``` ui.add(selector, styles, ?config)``` - добавляет стиль. Есть возможность вложженых стиле, доабвление псевдо классов, media стили. 
Возращает функцию для удаления правила.

Например: 
    ```
        
        ui.add(".button", {
            backgroundColor: "white",
            
            "&:hover": {
                color: "red",
            },
            
            "span": {
                fontSize: "18px",
            }
        })
        
        // еще можно так:
        ui.add("@media screen and (max-width: 300px)", {
            ".box": {
                color: "red",
                span: {
                    fontSize: "15px",
                }
            },
            body: {
                backgroundColor: "white",
            }
        }
        
    ```
    
Надеюсь стало понятнее как правильно писать стили и в каком виде.

Настройки добавления стилей:
```
{

    toVar, // если true, то переделывает все ключи в переменные (добавляет "--" именем стиля)

    index, // можно выбрать индекс под которым установить правило в таблцие стилей.

    global, // true, если не нужно использовать envSelector.

    sheet, // если нужно установить свою таблицу стиелей.

}
```

``` ui.remove(selector | index, ?sheet) ``` - передаете либо селектор стиля, либо индекс стиля и таблицу стиля (если она не this.sheet).

``` ui.find(selector, ?sheet) ``` - находит в таблице стилей стиль под переданным селектором и возращает либо null либо css правило (CSSStyleRule)

``` ui.toString(styles) ``` - переделывает объект стилей в правельный css формат и возращает строку.

``` ui.parse(cssText) ``` - парсит из текста css стили и превращает их в объект. 

``` ui.toVar(styles) ``` - переделывает все ключи объекта в переменные.

###### **BetterInline:**

``` editor.inline ``` - экземпляр класса BatterInline

**Он имеет следующие методы и свойства:**

``` const inline = editor.inline ```

Свойства:

``` inline.state ``` - объект состояния.

Методы:

``` inline.highestNode(childNode) ``` -  идет вверх по родительским нодам пока не дойдет до поля ввода.

``` inline.lowestNode(parentNode) ``` - ищет наиболее детскую ноду, текстовое содержимое которого равняется переданной ноде.

``` inline.select(node) ``` - выделяет содердимое переданной ноды.

``` inline.selectionHtml(?Range) ``` - возращает html контент выделения или переданного диопазона выделения.

``` inline.wrapSelection() ``` - оборачивает выделение в символы: {{выделенный текст}}. Это нцжно что бы потом не потерять выделение.

``` inline.unwrapSelection(node) ``` - ищет выделение символами {{выделенный текст}} в переденной ноде и убирает его.

``` inline.wrapText(node) ``` - оборачивает выделение в переданную ноду. Выделение сохраняется.

``` inline.unwrapText(selector) ``` - по селектору ищет ноду в выделении и убирает ее, сохраняя ее контент и само выделение.

``` inline.getInput() ``` - получает поле ввода, в котором было выделение и возращает либо null (выделения нет) либо елемент.

``` inline.getContainer() ``` - иногда в выжелении нодой является текстовая нода и с ней не всегда удобно работать. функция возращает первый родительский элемент тектсовой ноды в выделении ЕСЛИ выделенной нодой является только текст. Иначе вернет ноду которая была выделенна. Если выделения нет - возращает null.

``` inline.getSelectedNodes() ``` - возращает массив html элементов которые были выделены.

``` inline.isWrap(selector, ?getEl = false) ``` - возращает булево значение - есть ли в выделении элемент с переданным селектором. Если аргумент равняется true, то возращает этот элемент или false.

``` inline.fakeRange() ``` - оборачивает выделение в фейковое, что бы сохранить его. Если оно уже установлено, то ничего не делает.

``` inline.delFakeRange() ``` - удаляет фейковое выделение и создает настоящее выделени.

``` inline.cleanHtml(?inp) ``` - удаляет странный и не логичный html и чистит его от пустых элементов. Вы можете передать поле ввода или функция сама найдет это поле.

``` inline.selection() ``` - я подумал и понял, что методов слишком много. и при работе с выделением вызов каждрго метода может занять место и все это станет не читабельным. Поэтому я сделал функцию, которая возращает большинство информации о выделении.

**Кароче**, функция возращает объект: 
```
{

    selection, //объек выделения Selection

    range, // если есть выделение, то тут будет объект Range, иначе null

    content, // выделенный текст или пустая строка

    html, // html выделения

    input, // поле ввода выделения или null

    container, // первый html элемент выделения

    nodes, // html элементы внутри выделения

    lowestNode, // минимальная нода (из метода inline.lowestNode()

    highestNode, // максимальная нода (из метода inline.highestNode()

} = inline.selection()
```
